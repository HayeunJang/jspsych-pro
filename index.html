<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Speech Recording Experiment</title>
  <link rel="stylesheet" href="https://unpkg.com/jspsych@8.0.0/css/jspsych.css">
  <script src="https://unpkg.com/jspsych@8.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@2.0.0"></script>
  <style>
    .recording-container {
      text-align: center;
      padding: 40px;
      max-width: 800px;
      margin: 0 auto;
    }
    .sentence-display {
      font-size: 28px;
      font-weight: bold;
      padding: 30px;
      margin: 30px 0;
      background: #f0f0f0;
      border-radius: 10px;
      line-height: 1.6;
    }
    .recording-status {
      font-size: 20px;
      margin: 20px 0;
      min-height: 30px;
    }
    .recording-active {
      color: #dc3545;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }
    .timer {
      font-size: 24px;
      font-weight: bold;
      margin: 15px 0;
    }
    .next-button {
      font-size: 18px;
      padding: 15px 40px;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div id="jspsych-target"></div>
  
  <script>
    /******************************************************
     * Speech Recording Experiment
     ******************************************************/

    console.log('Script starting...');

    /* ===== CONFIG ===== */
    const GAS_ENDPOINT = 'YOUR_APPS_SCRIPT_URL';  // TODO: Apps Script URL
    const BEEP_DURATION = 500; // ì‚ ì†Œë¦¬ ê¸¸ì´ (ms)
    const MIN_RECORDING_TIME = 3000; // ìµœì†Œ ë…¹ìŒ ì‹œê°„ (ms)

    /* ===== UI TEXTS ===== */
    const TEXTS = {
      welcomeTitle: 'Speech Recording Experiment',
      welcomeBody: 'í™”ë©´ì— í‘œì‹œë˜ëŠ” ë¬¸ì¥ì„ ìì—°ìŠ¤ëŸ½ê²Œ ì½ì–´ì£¼ì„¸ìš”.<br>ì‚ ì†Œë¦¬ê°€ ë‚˜ë©´ ë…¹ìŒì´ ì‹œì‘ë©ë‹ˆë‹¤.<br><strong>ì¡°ìš©í•œ í™˜ê²½ì—ì„œ ì§„í–‰í•´ì£¼ì„¸ìš”.</strong>',
      startBtn: 'Start',
      recordingReady: 'ì¤€ë¹„...',
      recordingActive: 'ğŸ”´ ë…¹ìŒ ì¤‘...',
      recordingDone: 'ë…¹ìŒ ì™„ë£Œ! ë‹¤ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.',
      nextBtn: 'ë‹¤ìŒ',
      endTitle: 'ê°ì‚¬í•©ë‹ˆë‹¤!',
      endBody: 'ì‹¤í—˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë…¹ìŒ íŒŒì¼ì„ ì—…ë¡œë“œ ì¤‘ì…ë‹ˆë‹¤...',
      finishBtn: 'ì¢…ë£Œ'
    };

    /* ===== SENTENCES TO RECORD ===== */
    const SENTENCES = [
      "ì•ˆë…•",
      "ì˜ê°€"
    ];

    /* ===== GLOBAL STATE ===== */
    let mediaRecorder = null;
    let audioChunks = [];
    let recordedBlobs = []; // ëª¨ë“  ë…¹ìŒ íŒŒì¼ ì €ì¥
    let participantId = null;
    let currentTimerInterval = null;

    /* ===== INIT ===== */
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      on_finish: async () => {
        console.log('Experiment finished, uploading...');
        await uploadRecordingsToGoogleDrive();
      }
    });

    /* ===== WELCOME ===== */
    const welcome = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `<h2>${TEXTS.welcomeTitle}</h2><p>${TEXTS.welcomeBody}</p>`,
      choices: [TEXTS.startBtn]
    };

    /* ===== MICROPHONE PERMISSION ===== */
    const mic_permission = {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<h3>ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­</h3><p>ë…¹ìŒì„ ìœ„í•´ ë§ˆì´í¬ ì‚¬ìš©ì„ í—ˆìš©í•´ì£¼ì„¸ìš”.</p>',
      choices: ['ë§ˆì´í¬ í—ˆìš©'],
      on_finish: async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach(track => track.stop()); // ê¶Œí•œë§Œ ë°›ê³  ì¤‘ì§€
          console.log('Microphone permission granted');
        } catch (err) {
          alert('ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í—ˆìš©í•´ì£¼ì„¸ìš”.');
          console.error('Microphone error:', err);
        }
      }
    };

    /* ===== RECORDING TRIAL FACTORY ===== */
    function makeRecordingTrial(sentence, index) {
      return {
        type: jsPsychHtmlButtonResponse,
        stimulus: () => {
          return `
            <div class="recording-container">
              <div class="sentence-display">${sentence}</div>
              <div class="recording-status" id="status">${TEXTS.recordingReady}</div>
              <div class="timer" id="timer"></div>
            </div>
          `;
        },
        choices: [TEXTS.nextBtn],
        button_html: '<button class="jspsych-btn next-button" disabled style="opacity: 0.5;">%choice%</button>',
        on_load: function() {
          console.log(`Trial ${index + 1} loaded: "${sentence}"`);
          audioChunks = [];
          
          // ë¹„ë™ê¸° ì‹œí€€ìŠ¤ ì‹œì‘ (ì¦‰ì‹œ ì‹¤í–‰)
          (async () => {
            try {
              // 2ì´ˆ ëŒ€ê¸°
              console.log('Waiting 2 seconds...');
              await new Promise(resolve => setTimeout(resolve, 2000));
              
              // ì‚ ì†Œë¦¬ ì¬ìƒ
              console.log('Playing beep...');
              await playBeep();
              
              // ë…¹ìŒ ì‹œì‘
              console.log('Starting recording...');
              await startRecording();
              
              // ìƒíƒœ ì—…ë°ì´íŠ¸
              const statusEl = document.getElementById('status');
              if (statusEl) {
                statusEl.innerHTML = TEXTS.recordingActive;
                statusEl.classList.add('recording-active');
              }
              
              // íƒ€ì´ë¨¸ í‘œì‹œ
              let seconds = 0;
              currentTimerInterval = setInterval(() => {
                seconds++;
                const timerEl = document.getElementById('timer');
                if (timerEl) {
                  timerEl.textContent = `${seconds}ì´ˆ`;
                }
              }, 1000);
              
              // ìµœì†Œ ë…¹ìŒ ì‹œê°„ í›„ ë‹¤ìŒ ë²„íŠ¼ í™œì„±í™”
              await new Promise(resolve => setTimeout(resolve, MIN_RECORDING_TIME));
              
              const btn = document.querySelector('.next-button');
              const statusEl2 = document.getElementById('status');
              
              if (btn) {
                btn.disabled = false;
                btn.style.opacity = '1';
              }
              if (statusEl2) {
                statusEl2.innerHTML = TEXTS.recordingDone;
                statusEl2.classList.remove('recording-active');
              }
              if (currentTimerInterval) {
                clearInterval(currentTimerInterval);
                currentTimerInterval = null;
              }
              
              console.log('Recording ready for next');
            } catch (err) {
              console.error('Error in recording sequence:', err);
              alert('ë…¹ìŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + err.message);
            }
          })();
        },
        on_finish: async (data) => {
          console.log(`Trial ${index + 1} finishing...`);
          
          // íƒ€ì´ë¨¸ ì •ë¦¬
          if (currentTimerInterval) {
            clearInterval(currentTimerInterval);
            currentTimerInterval = null;
          }
          
          // ë…¹ìŒ ì¤‘ì§€
          if (mediaRecorder && mediaRecorder.state === 'recording') {
            await stopRecording();
          }
          
          // ë…¹ìŒ íŒŒì¼ ì €ì¥
          if (audioChunks.length > 0) {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            recordedBlobs.push({
              sentence: sentence,
              index: index,
              blob: audioBlob,
              timestamp: new Date().toISOString()
            });
            console.log(`Recording ${index + 1} saved:`, audioBlob.size, 'bytes');
          } else {
            console.warn(`No audio data for recording ${index + 1}`);
          }
          
          data.task = 'recording';
          data.sentence = sentence;
          data.sentence_index = index;
          data.timestamp = new Date().toISOString();
        }
      };
    }

    /* ===== BEEP SOUND ===== */
    function playBeep() {
      return new Promise((resolve) => {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.frequency.value = 800; // 800Hz
          oscillator.type = 'sine';
          gainNode.gain.value = 0.3;
          
          oscillator.start();
          setTimeout(() => {
            oscillator.stop();
            resolve();
          }, BEEP_DURATION);
        } catch (err) {
          console.error('Beep error:', err);
          resolve(); // ì‚ ì†Œë¦¬ ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰
        }
      });
    }

    /* ===== RECORDING FUNCTIONS ===== */
    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };
        
        mediaRecorder.start();
        console.log('Recording started');
      } catch (err) {
        console.error('Recording error:', err);
        alert('ë…¹ìŒì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + err.message);
        throw err;
      }
    }

    function stopRecording() {
      return new Promise((resolve) => {
        if (!mediaRecorder) {
          resolve();
          return;
        }
        
        if (mediaRecorder.state === 'inactive') {
          resolve();
          return;
        }
        
        mediaRecorder.onstop = () => {
          mediaRecorder.stream.getTracks().forEach(track => track.stop());
          console.log('Recording stopped');
          resolve();
        };
        
        mediaRecorder.stop();
      });
    }

    /* ===== DEMOGRAPHICS ===== */
    const demographics = {
      type: jsPsychSurveyHtmlForm,
      preamble: '<h3>ì°¸ê°€ì ì •ë³´</h3><p>ì•„ë˜ ì •ë³´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.</p>',
      html: `
        <div style="text-align: left; max-width: 500px; margin: 0 auto;">
          <p><label for="gender"><strong>ì„±ë³„:</strong></label><br>
          <input type="radio" name="gender" value="ë‚¨" required> ë‚¨
          <input type="radio" name="gender" value="ì—¬" required> ì—¬</p>
          
          <p><label for="birth_year"><strong>íƒœì–´ë‚œ í•´:</strong></label><br>
          <input type="text" id="birth_year" name="birth_year" placeholder="YYYY (ì˜ˆ: 1995)" pattern="[0-9]{4}" required style="width: 150px;"></p>
          
          <p><label for="birth_month"><strong>íƒœì–´ë‚œ ì›”:</strong></label><br>
          <input type="text" id="birth_month" name="birth_month" placeholder="MM (ì˜ˆ: 03)" pattern="[0-9]{2}" required style="width: 80px;"></p>
          
          <p><label for="native_lang"><strong>ëª¨êµ­ì–´:</strong></label><br>
          <input type="text" id="native_lang" name="native_lang" placeholder="ì˜ˆ: í•œêµ­ì–´" required style="width: 200px;"></p>
          
          <p><label for="dialect"><strong>ë°©ì–¸:</strong></label><br>
          <input type="text" id="dialect" name="dialect" placeholder="ì˜ˆ: ì„œìš¸, ê²½ìƒë„" style="width: 200px;"></p>
          
          <p><label for="foreign_lang"><strong>ì™¸êµ­ì–´:</strong></label><br>
          <input type="text" id="foreign_lang" name="foreign_lang" placeholder="ì˜ˆ: ì˜ì–´, ì¼ë³¸ì–´" style="width: 300px;"></p>
        </div>
      `,
      button_label: 'ì œì¶œ',
      data: { task: 'demographics' },
      on_finish: (data) => {
        data.timestamp = new Date().toISOString();
        // participant_id ìƒì„± (timestamp ê¸°ë°˜)
        participantId = 'P' + Date.now();
        data.participant_id = participantId;
        console.log('Participant ID:', participantId);
        console.log('Demographics:', data.response);
      }
    };

    /* ===== END ===== */
    const end = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `<h2>${TEXTS.endTitle}</h2><p>${TEXTS.endBody}</p>`,
      choices: [TEXTS.finishBtn]
    };

    /* ===== BUILD TIMELINE ===== */
    const recording_trials = SENTENCES.map((sentence, index) => 
      makeRecordingTrial(sentence, index)
    );

    /* ===== RUN ===== */
    console.log('Starting experiment...');
    jsPsych.run([
      welcome,
      mic_permission,
      ...recording_trials,
      demographics,
      end
    ]);

    /* ===== GOOGLE DRIVE UPLOAD ===== */
    async function uploadRecordingsToGoogleDrive() {
      if (!GAS_ENDPOINT || GAS_ENDPOINT === 'https://script.google.com/macros/s/AKfycbyGAuNG2gQN-aekZ4u25-n6wpEj0mvfYK5qwbGxfrdsI-f7yyZ01aoskLsOv13cxk53OQ/exec') {
        console.warn('No Google Apps Script endpoint configured.');
        downloadRecordingsAsZip(); // fallback: ë¡œì»¬ ë‹¤ìš´ë¡œë“œ
        return;
      }

      try {
        const demoData = jsPsych.data.get().filter({task: 'demographics'}).values()[0];
        const demographics = demoData?.response || {};

        for (let i = 0; i < recordedBlobs.length; i++) {
          const item = recordedBlobs[i];
          
          // Blobì„ Base64ë¡œ ë³€í™˜
          const base64Audio = await blobToBase64(item.blob);
          
          const payload = {
            participant_id: participantId || 'unknown',
            sentence_index: item.index,
            sentence: item.sentence,
            audio_data: base64Audio,
            timestamp: item.timestamp,
            demographics: demographics
          };

          await fetch(GAS_ENDPOINT, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          console.log(`Uploaded recording ${i + 1}/${recordedBlobs.length}`);
        }

        console.log('All recordings uploaded successfully');
      } catch (err) {
        console.error('Upload error:', err);
        downloadRecordingsAsZip(); // fallback
      }
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result.split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    /* ===== FALLBACK: LOCAL DOWNLOAD ===== */
    function downloadRecordingsAsZip() {
      recordedBlobs.forEach((item, index) => {
        const url = URL.createObjectURL(item.blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `recording_${index + 1}_${item.sentence.substring(0, 10)}.webm`;
        a.click();
        URL.revokeObjectURL(url);
      });
      console.log('Downloaded all recordings locally');
    }
  </script>
</body>
</html>
