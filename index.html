<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Speech Recording Experiment</title>
  <link rel="stylesheet" href="https://unpkg.com/jspsych@8.0.0/css/jspsych.css">
  <script src="https://unpkg.com/jspsych@8.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@2.0.0"></script>
  <style>
    .recording-container {
      text-align: center;
      padding: 40px;
      max-width: 800px;
      margin: 0 auto;
    }
    .sentence-display {
      font-size: 28px;
      font-weight: bold;
      padding: 30px;
      margin: 30px 0;
      background: #f0f0f0;
      border-radius: 10px;
      line-height: 1.6;
    }
    .recording-status {
      font-size: 20px;
      margin: 20px 0;
      min-height: 30px;
    }
    .recording-active {
      color: #dc3545;
      animation: blink 1s infinite;
    }
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }
    .timer {
      font-size: 24px;
      font-weight: bold;
      margin: 15px 0;
    }
    .control-buttons {
      margin-top: 30px;
    }
    .control-buttons button {
      font-size: 18px;
      padding: 15px 40px;
      margin: 0 10px;
      cursor: pointer;
    }
    .record-btn {
      background-color: #dc3545;
      color: white;
      border: none;
      border-radius: 5px;
    }
    .record-btn:hover:not(:disabled) {
      background-color: #c82333;
    }
    .stop-btn {
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 5px;
    }
    .stop-btn:hover:not(:disabled) {
      background-color: #218838;
    }
    .next-btn {
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
    }
    .next-btn:hover:not(:disabled) {
      background-color: #0069d9;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div id="jspsych-target"></div>
  
  <script>
    /******************************************************
     * Speech Recording Experiment - Manual Control
     ******************************************************/

    console.log('Script starting...');

    /* ===== CONFIG ===== */
    const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbyGAuNG2gQN-aekZ4u25-n6wpEj0mvfYK5qwbGxfrdsI-f7yyZ01aoskLsOv13cxk53OQ/exec';

    /* ===== UI TEXTS ===== */
    const TEXTS = {
      welcomeTitle: 'Speech Recording Experiment',
      welcomeBody: 'ÌôîÎ©¥Ïóê ÌëúÏãúÎêòÎäî Î¨∏Ïû•ÏùÑ ÏûêÏó∞Ïä§ÎüΩÍ≤å ÏùΩÏñ¥Ï£ºÏÑ∏Ïöî.<br><strong>Ï°∞Ïö©Ìïú ÌôòÍ≤ΩÏóêÏÑú ÏßÑÌñâÌï¥Ï£ºÏÑ∏Ïöî.</strong>',
      startBtn: 'Start',
      ready: 'Ï§ÄÎπÑÎêòÎ©¥ ÎÖπÏùå Î≤ÑÌäºÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî',
      recording: 'üî¥ ÎÖπÏùå Ï§ë...',
      stopped: 'ÎÖπÏùåÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïùå Î≤ÑÌäºÏùÑ ÎàåÎü¨Ï£ºÏÑ∏Ïöî.',
      recordBtn: 'ÎÖπÏùå ÏãúÏûë',
      stopBtn: 'ÎÖπÏùå ÏôÑÎ£å',
      nextBtn: 'Îã§Ïùå',
      endTitle: 'Í∞êÏÇ¨Ìï©ÎãàÎã§!',
      endBody: 'Ïã§ÌóòÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. ÎÖπÏùå ÌååÏùºÏùÑ ÏóÖÎ°úÎìú Ï§ëÏûÖÎãàÎã§...',
      finishBtn: 'Ï¢ÖÎ£å'
    };

    /* ===== SENTENCES TO RECORD ===== */
    const SENTENCES = [
      "ÏïàÎÖï",
      "ÏûòÍ∞Ä"
    ];

    /* ===== GLOBAL STATE ===== */
    let mediaRecorder = null;
    let audioChunks = [];
    let recordedBlobs = [];
    let participantId = null;
    let currentTimerInterval = null;
    let isRecording = false;

    /* ===== INIT ===== */
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      on_finish: async () => {
        console.log('Experiment finished, uploading...');
        await uploadRecordingsToGoogleDrive();
      }
    });

    /* ===== WELCOME ===== */
    const welcome = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `<h2>${TEXTS.welcomeTitle}</h2><p>${TEXTS.welcomeBody}</p>`,
      choices: [TEXTS.startBtn]
    };

    /* ===== MICROPHONE PERMISSION ===== */
    const mic_permission = {
      type: jsPsychHtmlButtonResponse,
      stimulus: '<h3>ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÏöîÏ≤≠</h3><p>ÎÖπÏùåÏùÑ ÏúÑÌï¥ ÎßàÏù¥ÌÅ¨ ÏÇ¨Ïö©ÏùÑ ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.</p>',
      choices: ['ÎßàÏù¥ÌÅ¨ ÌóàÏö©'],
      on_finish: async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach(track => track.stop());
          console.log('Microphone permission granted');
        } catch (err) {
          alert('ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏóêÏÑú ÎßàÏù¥ÌÅ¨Î•º ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.');
          console.error('Microphone error:', err);
        }
      }
    };

    /* ===== RECORDING TRIAL FACTORY ===== */
    function makeRecordingTrial(sentence, index) {
      return {
        type: jsPsychHtmlButtonResponse,
        stimulus: () => {
          return `
            <div class="recording-container">
              <div class="sentence-display">${sentence}</div>
              <div class="recording-status" id="status">${TEXTS.ready}</div>
              <div class="timer" id="timer"></div>
              <div class="control-buttons">
                <button class="record-btn" id="recordBtn" onclick="handleRecord()">${TEXTS.recordBtn}</button>
                <button class="stop-btn" id="stopBtn" onclick="handleStop()" disabled>${TEXTS.stopBtn}</button>
                <button class="next-btn" id="nextBtn" style="display:none;">${TEXTS.nextBtn}</button>
              </div>
            </div>
          `;
        },
        choices: [],
        on_load: function() {
          console.log(`Trial ${index + 1} loaded: "${sentence}"`);
          audioChunks = [];
          isRecording = false;
          
          // Ï†ÑÏó≠ Ìï®ÏàòÎ°ú Î≤ÑÌäº Ìï∏Îì§Îü¨ Ï†ïÏùò
          window.handleRecord = async () => {
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            const statusEl = document.getElementById('status');
            
            if (isRecording) return;
            
            try {
              await startRecording();
              isRecording = true;
              
              recordBtn.disabled = true;
              stopBtn.disabled = false;
              
              if (statusEl) {
                statusEl.innerHTML = TEXTS.recording;
                statusEl.classList.add('recording-active');
              }
              
              // ÌÉÄÏù¥Î®∏ ÏãúÏûë
              let seconds = 0;
              currentTimerInterval = setInterval(() => {
                seconds++;
                const timerEl = document.getElementById('timer');
                if (timerEl) {
                  timerEl.textContent = `${seconds}Ï¥à`;
                }
              }, 1000);
              
              console.log('Recording started by user');
            } catch (err) {
              console.error('Failed to start recording:', err);
              alert('ÎÖπÏùå ÏãúÏûë Ïã§Ìå®: ' + err.message);
            }
          };
          
          window.handleStop = async () => {
            const recordBtn = document.getElementById('recordBtn');
            const stopBtn = document.getElementById('stopBtn');
            const nextBtn = document.getElementById('nextBtn');
            const statusEl = document.getElementById('status');
            
            if (!isRecording) return;
            
            try {
              await stopRecording();
              isRecording = false;
              
              stopBtn.disabled = true;
              
              if (statusEl) {
                statusEl.innerHTML = TEXTS.stopped;
                statusEl.classList.remove('recording-active');
              }
              
              // ÌÉÄÏù¥Î®∏ Ï†ïÏßÄ
              if (currentTimerInterval) {
                clearInterval(currentTimerInterval);
                currentTimerInterval = null;
              }
              
              // ÎÖπÏùå ÌååÏùº Ï†ÄÏû•
              if (audioChunks.length > 0) {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                recordedBlobs.push({
                  sentence: sentence,
                  index: index,
                  blob: audioBlob,
                  timestamp: new Date().toISOString()
                });
                console.log(`Recording ${index + 1} saved:`, audioBlob.size, 'bytes');
              }
              
              // Îã§Ïùå Î≤ÑÌäº ÌëúÏãú
              if (nextBtn) {
                nextBtn.style.display = 'inline-block';
                nextBtn.onclick = () => {
                  jsPsych.finishTrial({
                    task: 'recording',
                    sentence: sentence,
                    sentence_index: index,
                    timestamp: new Date().toISOString()
                  });
                };
              }
              
              console.log('Recording stopped by user');
            } catch (err) {
              console.error('Failed to stop recording:', err);
            }
          };
        }
      };
    }

    /* ===== RECORDING FUNCTIONS ===== */
    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };
        
        mediaRecorder.start();
        console.log('MediaRecorder started');
      } catch (err) {
        console.error('Recording error:', err);
        throw err;
      }
    }

    function stopRecording() {
      return new Promise((resolve) => {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') {
          resolve();
          return;
        }
        
        mediaRecorder.onstop = () => {
          mediaRecorder.stream.getTracks().forEach(track => track.stop());
          console.log('MediaRecorder stopped');
          resolve();
        };
        
        mediaRecorder.stop();
      });
    }

    /* ===== DEMOGRAPHICS ===== */
    const demographics = {
      type: jsPsychSurveyHtmlForm,
      preamble: '<h3>Ï∞∏Í∞ÄÏûê Ï†ïÎ≥¥</h3><p>ÏïÑÎûò Ï†ïÎ≥¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.</p>',
      html: `
        <div style="text-align: left; max-width: 500px; margin: 0 auto;">
          <p><label for="gender"><strong>ÏÑ±Î≥Ñ:</strong></label><br>
          <input type="radio" name="gender" value="ÎÇ®" required> ÎÇ®
          <input type="radio" name="gender" value="Ïó¨" required> Ïó¨</p>
          
          <p><label for="birth_year"><strong>ÌÉúÏñ¥ÎÇú Ìï¥:</strong></label><br>
          <input type="text" id="birth_year" name="birth_year" placeholder="YYYY (Ïòà: 1995)" pattern="[0-9]{4}" required style="width: 150px;"></p>
          
          <p><label for="birth_month"><strong>ÌÉúÏñ¥ÎÇú Ïõî:</strong></label><br>
          <input type="text" id="birth_month" name="birth_month" placeholder="MM (Ïòà: 03)" pattern="[0-9]{2}" required style="width: 80px;"></p>
          
          <p><label for="native_lang"><strong>Î™®Íµ≠Ïñ¥:</strong></label><br>
          <input type="text" id="native_lang" name="native_lang" placeholder="Ïòà: ÌïúÍµ≠Ïñ¥" required style="width: 200px;"></p>
          
          <p><label for="dialect"><strong>Î∞©Ïñ∏:</strong></label><br>
          <input type="text" id="dialect" name="dialect" placeholder="Ïòà: ÏÑúÏö∏, Í≤ΩÏÉÅÎèÑ" style="width: 200px;"></p>
          
          <p><label for="foreign_lang"><strong>Ïô∏Íµ≠Ïñ¥:</strong></label><br>
          <input type="text" id="foreign_lang" name="foreign_lang" placeholder="Ïòà: ÏòÅÏñ¥, ÏùºÎ≥∏Ïñ¥" style="width: 300px;"></p>
        </div>
      `,
      button_label: 'Ï†úÏ∂ú',
      data: { task: 'demographics' },
      on_finish: (data) => {
        data.timestamp = new Date().toISOString();
        participantId = 'P' + Date.now();
        data.participant_id = participantId;
        console.log('Participant ID:', participantId);
        console.log('Demographics:', data.response);
      }
    };

    /* ===== END ===== */
    const end = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `<h2>${TEXTS.endTitle}</h2><p>${TEXTS.endBody}</p>`,
      choices: [TEXTS.finishBtn]
    };

    /* ===== BUILD TIMELINE ===== */
    const recording_trials = SENTENCES.map((sentence, index) => 
      makeRecordingTrial(sentence, index)
    );

    /* ===== RUN ===== */
    console.log('Starting experiment...');
    jsPsych.run([
      welcome,
      mic_permission,
      ...recording_trials,
      demographics,
      end
    ]);

    /* ===== GOOGLE DRIVE UPLOAD ===== */
    async function uploadRecordingsToGoogleDrive() {
      if (!GAS_ENDPOINT || GAS_ENDPOINT === 'https://script.google.com/macros/s/AKfycbyGAuNG2gQN-aekZ4u25-n6wpEj0mvfYK5qwbGxfrdsI-f7yyZ01aoskLsOv13cxk53OQ/exec') {
        console.warn('No Google Apps Script endpoint configured.');
        downloadRecordingsAsZip();
        return;
      }

      try {
        const demoData = jsPsych.data.get().filter({task: 'demographics'}).values()[0];
        const demographics = demoData?.response || {};

        for (let i = 0; i < recordedBlobs.length; i++) {
          const item = recordedBlobs[i];
          
          const base64Audio = await blobToBase64(item.blob);
          
          const payload = {
            participant_id: participantId || 'unknown',
            sentence_index: item.index,
            sentence: item.sentence,
            audio_data: base64Audio,
            timestamp: item.timestamp,
            demographics: demographics
          };

          await fetch(GAS_ENDPOINT, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          console.log(`Uploaded recording ${i + 1}/${recordedBlobs.length}`);
        }

        console.log('All recordings uploaded successfully');
      } catch (err) {
        console.error('Upload error:', err);
        downloadRecordingsAsZip();
      }
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result.split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    /* ===== FALLBACK: LOCAL DOWNLOAD ===== */
    function downloadRecordingsAsZip() {
      recordedBlobs.forEach((item, index) => {
        const url = URL.createObjectURL(item.blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `recording_${participantId}_${index + 1}_${item.sentence}.webm`;
        a.click();
        URL.revokeObjectURL(url);
      });
      console.log('Downloaded all recordings locally');
    }
  </script>
</body>
</html>
